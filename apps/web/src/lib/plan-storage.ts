/**
 * PlanStorage — dual-mode plan file management.
 *
 * Local dev: writes/moves markdown plan files in vault folders.
 * Vercel/cloud: skips filesystem writes; plan content lives in DB only.
 */
import fs from 'fs'
import path from 'path'
import { prisma } from '@/lib/db'

const IS_VERCEL = process.env.VERCEL === '1' || process.env.VERCEL_ENV !== undefined

function getRepoRoot(): string {
  if (process.env.REPO_ROOT) return process.env.REPO_ROOT
  return path.resolve(process.cwd(), '..', '..')
}

function safeEnsureDir(dirPath: string) {
  try {
    if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath, { recursive: true })
  } catch { /* no-op on Vercel */ }
}

function safeWriteFile(filePath: string, content: string) {
  try {
    safeEnsureDir(path.dirname(filePath))
    fs.writeFileSync(filePath, content, 'utf-8')
    return true
  } catch {
    return false
  }
}

function safeMove(src: string, dest: string) {
  try {
    safeEnsureDir(path.dirname(dest))
    fs.renameSync(src, dest)
    return true
  } catch {
    // Try copy+delete as fallback (cross-device move)
    try {
      fs.copyFileSync(src, dest)
      fs.unlinkSync(src)
      return true
    } catch {
      return false
    }
  }
}

// ── Plan markdown renderer ────────────────────────────────────────────────────

export function renderPlanMarkdown(plan: {
  id: string
  title: string
  channel: string
  actionType: string
  payload: Record<string, unknown>
  status: string
  scheduledAt?: Date | null
  userId: string
  createdAt: Date
}): string {
  const { id, title, channel, actionType, payload, status, scheduledAt, userId, createdAt } = plan
  const p = payload as Record<string, unknown>

  const scheduleStr = scheduledAt
    ? scheduledAt.toISOString()
    : 'now'

  const imageSection = p.imageMode === 'none' || !p.imageMode
    ? '- **Image:** None'
    : p.imageMode === 'generate'
    ? `- **Image:** AI-generated\n  - Style: ${p.imageStyle ?? ''}\n  - Subject: ${p.imageSubject ?? ''}\n  - Vibe: ${p.imageVibe ?? ''}`
    : `- **Image:** Upload\n  - File: ${p.imageFile ?? 'provided'}`

  return `---
id: ${id}
title: ${title}
channel: ${channel}
action_type: ${actionType}
status: ${status}
created: ${createdAt.toISOString()}
scheduled: ${scheduleStr}
user_id: ${userId}
---

# ${title}

## Action Details
- **Channel:** ${channel.charAt(0).toUpperCase() + channel.slice(1)}
- **Action Type:** ${actionType}
- **Intent:** ${p.intent ?? 'general'}
- **Status:** ${status}

## Content
- **Topic:** ${p.topic ?? ''}
- **Tone:** ${p.tone ?? 'professional'}
- **Length:** ${p.length ?? 'medium'}

## Post / Message Body

${p.body ?? p.content ?? p.subject ?? '(to be generated)'}

## Hashtags

${Array.isArray(p.hashtags) ? p.hashtags.map((h: unknown) => `#${String(h).replace(/^#/, '')}`).join(' ') : (p.hashtags ?? '')}

## Call to Action

${p.cta ?? ''}

## Image

${imageSection}

## Schedule

- **When:** ${scheduleStr}
- **Timezone:** ${p.timezone ?? 'UTC'}

## Recipients / Audience

${p.recipient ?? p.audience ?? 'Public'}

---
*Generated by Personal AI Employee Web Control Plane*
*Approval required before execution.*
`
}

// ── Storage operations ────────────────────────────────────────────────────────

export async function writePlanToFs(
  planId: string,
  title: string,
  markdown: string
): Promise<string | null> {
  if (IS_VERCEL) return null

  const root = getRepoRoot()
  const safeTitle = title.replace(/[^a-z0-9]+/gi, '_').slice(0, 40)
  const ts = new Date().toISOString().replace(/[-:T.Z]/g, '').slice(0, 12)
  const filename = `WEBPLAN_${ts}_${safeTitle}.md`
  const filePath = path.join(root, 'Pending_Approval', filename)

  const wrote = safeWriteFile(filePath, markdown)
  return wrote ? path.join('Pending_Approval', filename) : null
}

export async function movePlanToApproved(filePath: string | null): Promise<string | null> {
  if (IS_VERCEL || !filePath) return null

  const root = getRepoRoot()
  const filename = path.basename(filePath)
  const src = path.join(root, filePath)
  const dest = path.join(root, 'Approved', filename)

  const moved = safeMove(src, dest)
  return moved ? path.join('Approved', filename) : filePath
}

export async function movePlanToRejected(filePath: string | null): Promise<string | null> {
  if (IS_VERCEL || !filePath) return null

  const root = getRepoRoot()
  const filename = path.basename(filePath)
  const src = path.join(root, filePath)
  const dest = path.join(root, 'Rejected', filename)
  safeEnsureDir(path.join(root, 'Rejected'))

  const moved = safeMove(src, dest)
  return moved ? path.join('Rejected', filename) : filePath
}

// ── DB helpers ────────────────────────────────────────────────────────────────

export async function getPendingPlans(userId: string) {
  return prisma.webPlan.findMany({
    where: { userId, status: 'pending_approval' },
    orderBy: { createdAt: 'desc' },
    take: 20,
  })
}

export async function getApprovedPlans(userId: string) {
  return prisma.webPlan.findMany({
    where: { userId, status: { in: ['approved', 'scheduled'] } },
    orderBy: { createdAt: 'desc' },
    take: 20,
  })
}

export async function getRecentExecutedPlans(userId: string) {
  return prisma.webPlan.findMany({
    where: { userId, status: { in: ['executed', 'failed', 'rejected'] } },
    orderBy: { updatedAt: 'desc' },
    take: 20,
  })
}
